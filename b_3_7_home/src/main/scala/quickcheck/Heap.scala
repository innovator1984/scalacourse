package quickcheck

import common._

trait IntHeap extends Heap {
  override type A = Int
  override def ord = scala.math.Ordering.Int
}

// http://www.brics.dk/RS/96/37/BRICS-RS-96-37.pdf
// TODO 1.B Common
// Here is what you need to know about priority queues to complete the assignment.
// In a nutshell, a priority queue is like a queue, except it's not first-in first-out, but whatever-in minimum-out.
// Starting with the empty queue, you can construct a new non-empty bigger queue by recursively inserting an element.
// You can also meld two queues, which results in a new queue that contains all the elements of the first queue
// and all the elements of the second queue. You can test whether a queue is empty or not with isEmpty.
// If you have a non-empty queue, you can find its minimum with findMin. You can also get a smaller queue
// from a non-empty queue by deleting the minimum element with deleteMin.
//
// Only one of the several implementations you are given is correct. The other ones have bugs.
// Your goal is to write some properties that will be automatically checked.
// All the properties you write should be satisfiable by the correct implementation,
// while at least one of them should fail in each incorrect implementation, thus revealing itâ€™s buggy.
//
// You should write your properties in the body of the QuickCheckHeap class
// in the file src/main/scala/quickcheck/QuickCheck.scala.
// In this class, the heap operates on Int elements with the natural ordering,
// so findMin finds the least integer in the heap.
//
// We also recommend you write a generator of heaps, of abstract type H,
// so that you can write properties on any random heap, generated by your procedure. For example,
// property("gen1") = forAll { (h: H) =>
// val m = if (isEmpty(h)) 0 else findMin(h)
//   findMin(insert(m, h))==m
// }
// To get you in shape, here is an example of a generator for maps of type Map[Int,Int].
// lazy val genMap: Gen[Map[Int,Int]] = oneOf(
//   const(Map.empty[Int,Int]),
//   for {
//      k <- arbitrary[Int]
//      v <- arbitrary[Int]
//      m <- oneOf(const(Map.empty[Int,Int]), genMap)
//   } yield m.updated(k, v)
// )
// In order to get full credit, all tests should pass, that is you should correctly identify each buggy implementation
// while only writing properties that are true of heaps.
// You are free to write as many or as few properties as you want in order to achieve a full passing suite.

// Figure 1, page 3
trait Heap {
  type H // type of a heap
  type A // type of an element
  def ord: Ordering[A] // ordering on elements

  def empty: H // the empty heap
  def isEmpty(h: H): Boolean // whether the given heap h is empty

  def insert(x: A, h: H): H // the heap resulting from inserting x into h
  def meld(h1: H, h2: H): H // the heap resulting from merging h1 and h2

  def findMin(h: H): A // a minimum of the heap h
  def deleteMin(h: H): H // a heap resulting from deleting a minimum of h
}

// Figure 3, page 7
trait BinomialHeap extends Heap {

  type Rank = Int
  case class Node(x: A, r: Rank, c: List[Node])
  override type H = List[Node]

  protected def root(t: Node) = t.x
  protected def rank(t: Node) = t.r
  protected def link(t1: Node, t2: Node): Node = // t1.r==t2.r
    if (ord.lteq(t1.x,t2.x)) Node(t1.x, t1.r+1, t2::t1.c) else Node(t2.x, t2.r+1, t1::t2.c)
  protected def ins(t: Node, ts: H): H = ts match {
    case Nil => List(t)
    case tp::ts => // t.r<=tp.r
      if (t.r<tp.r) t::tp::ts else ins(link(t, tp), ts)
  }

  override def empty = Nil
  override def isEmpty(ts: H) = ts.isEmpty

  override def insert(x: A, ts: H) = ins(Node(x,0,Nil), ts)
  override def meld(ts1: H, ts2: H) = (ts1, ts2) match {
    case (Nil, ts) => ts
    case (ts, Nil) => ts
    case (t1::ts1, t2::ts2) =>
      if (t1.r<t2.r) t1::meld(ts1,t2::ts2)
      else if (t2.r<t1.r) t2::meld(t1::ts1,ts2)
      else ins(link(t1,t2),meld(ts1,ts2))
  }

  override def findMin(ts: H) = ts match {
    case Nil => throw new NoSuchElementException("min of empty heap")
    case t::Nil => root(t)
    case t::ts =>
      val x = findMin(ts)
      if (ord.lteq(root(t),x)) root(t) else x
  }

  override def deleteMin(ts: H) = ts match {
    case Nil => throw new NoSuchElementException("delete min of empty heap")
    case t::ts =>
      def getMin(t: Node, ts: H): (Node, H) = ts match {
        case Nil => (t, Nil)
        case tp::tsp =>
          val (tq,tsq) = getMin(tp, tsp)
          if (ord.lteq(root(t),root(tq))) (t,ts) else (tq,t::tsq)
      }
      val (Node(_,_,c),tsq) = getMin(t, ts)
      meld(c.reverse, tsq)
  }
}

trait Bogus1BinomialHeap extends BinomialHeap {
  override def findMin(ts: H) = ts match {
    case Nil => throw new NoSuchElementException("min of empty heap")
    case t::ts => root(t)
  }
}

trait Bogus2BinomialHeap extends BinomialHeap {
  override protected def link(t1: Node, t2: Node): Node = // t1.r==t2.r
    if (!ord.lteq(t1.x,t2.x)) Node(t1.x, t1.r+1, t2::t1.c) else Node(t2.x, t2.r+1, t1::t2.c)
}

trait Bogus3BinomialHeap extends BinomialHeap {
  override protected def link(t1: Node, t2: Node): Node = // t1.r==t2.r
    if (ord.lteq(t1.x,t2.x)) Node(t1.x, t1.r+1, t1::t1.c) else Node(t2.x, t2.r+1, t2::t2.c)
}

trait Bogus4BinomialHeap extends BinomialHeap {
  override def deleteMin(ts: H) = ts match {
    case Nil => throw new NoSuchElementException("delete min of empty heap")
    case t::ts => meld(t.c.reverse, ts)
  }
}

trait Bogus5BinomialHeap extends BinomialHeap {
  override def meld(ts1: H, ts2: H) = ts1 match {
    case Nil => ts2
    case t1::ts1 => List(Node(t1.x, t1.r, ts1++ts2))
  }
}
